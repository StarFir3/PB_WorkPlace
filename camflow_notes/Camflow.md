# PhD_Notes

## Camflow Concepts

In a computing context, data provenance represents, in a formal manner, the relationships between data items (entities), transformations applied to those items (activities), and persons or organisations associated with the data and transformations (agents).

- A provenance graph represents entities, activities and agents.
- At the OS level, entities are typically kernel data objects: files, messages, packets etc., but also xattributes, inode attributes, exec parameters, network addresses etc.  
- Activities are typically processes carrying out manipulations on entities.
- Agents are persons or organisations (e.g., users, groups etc.) on whose behalf the activities operate.
- In the provenance graph, all these elements are nodes, connected by edges representing different types of interactions.

## Analyzing Camflow Output

Count the number of lines in a Camflow output file

```shell
wc trace.data
```

Read output file line by line

```shell
sed -n 1p trace.data (line 1)
sed -n 2p trace.data (line 2)
```

The output generated by camflowd supports two formats: W3C PROV-JSON format and the PROV-JSON format. The PROV-JSON is CamFlow default output. Try to understand the Camflow output (JSON).

To understand the JSON output, use the [JSON code beautify](https://codebeautify.org/jsonviewer)

A sample output is shown below:

[//]: <img src="Images/camflow_json_1.PNG" width="360" height="170">

![](Images/camflow_json_1.PNG)

It will help to understand the JSON format output in a structured way. In the JSON viewer, we will able to obtain the following information:

Now, the `JSON output` can contain

- Vertices
  - entity
  - activity
- Edges
  - used
  - wasGeneratedBy
  - wasDerivedFrom

A sample output of Entity is

```json
"cf:AAAIAAAAACBQ8wAAAAAAAAEAAADE+3Y2AAAAAAAAAAA=":{
    "cf:id":"62288",
    "prov:type":"path",
    "cf:boot_id":1,
    "cf:machine_id":"cf:913767364",
    "cf:version":0,
    "cf:date":"2019:03:22T13:17:40",
    "cf:jiffies":"4294724646",
    "cf:epoch":0,
    "cf:pathname":"/usr/lib/x86_64-linux-gnu/libgobject-2.0.so.0.5600.2",
    "prov:label":"[path] /usr/lib/x86_64-linux-gnu/libgobject-2.0.so.0.5600.2"
},
```

- `cf:AAAIAAAAACBQ8wAAAAAAAAEAAADE+3Y2AAAAAAAAAAA=` represents the node identifier and is the [base64 of C datastructure.](https://github.com/CamFlow/camflow-dev/blob/master/include/uapi/linux/provenance.h#L68)
- JSON output following that is the serialisation of the [data structure](https://github.com/CamFlow/camflow-dev/blob/master/include/uapi/linux/provenance.h#L153)
- If we want to count the number of vertex in the `trace.data` mainly count the number of unique `cf:id`.
- The count of `cf:id` and the `hash of the data structure` should be equal. The number of different hashes should be the same as the number of nodes (which may include nodes of different versions).
- Each line of camflow output represents a bunch of data (nodes/edges).

The Vertices can have different types `prov:type` defined in [Vertices](https://github.com/CamFlow/camflow-dev/blob/master/docs/VERTICES.md)

```shell
file, task, pipe, directory, socket, path etc.
```

The sample output of Edges is

```json
cf:gAAAAAAAQIACAAAAAAAAAAEAAADE+3Y2AAAAAAAAAAA=":{
        "cf:id":"2",
        "prov:type":"memory_write",
        "cf:boot_id":1,
        "cf:machine_id":"cf:913767364",
        "cf:date":"2019:03:22T13:17:40",
        "cf:jiffies":"4294724256",
        "cf:epoch":0,
        "prov:label":"memory_write",
        "cf:allowed":"true",
        "prov:activity":"cf:AQAAAAAAAEDW8QAAAAAAAAEAAADE+3Y2AAAAAAAAAAA=",
        "prov:entity":"cf:AAAACAAAACDV8QAAAAAAAAEAAADE+3Y2AAAAAAAAAAA=",
        "cf:flags":"0"
}
```

The Relations (Edges) also have variour types of `prov:type` supported by [Camflow](https://github.com/CamFlow/camflow-dev/blob/master/docs/RELATIONS.md)

```shell
read, write, unknown, setuid, connect, open etc
```

## Graph Input

Provenance data in graph format.

See a [Sample Provenance graph](https://raw.githubusercontent.com/StarFir3/PB_WorkPlace/main/camflow_notes/Images/camflow_sample_graph.svg)

The above graph is for one small example of running a TCP client making a connection to `google.com` with the cmdline path `/home/vagrant/example/provenance/tcp-client`. The text on the circle denotes the `prov_type` and the text on the edge represents different edge type such as `Used`, `WasGeneratedBy` - `prov_type` of edge - `prov_label`.

As the program accesses `google.com`, it needs to resolve the `domainname` to an `IPAddress`. It probably does a system call which accesses the files such as `/etc/resolv.conf`, `/etc/host.conf`,  `/etc/hosts` and others to convert the `domainname` to an `IPAddress`.

### Problem

Graph Explosion Problem:

- The above sample graph of program running a `TCP connect`.
- That provanance graph of systems is large and usually spans over days and months which makes it difficult to analyse and identify the interesting (malicious) part.

Security Analysis Problem

- The security analyst must have tools to identify the malicious nodes and relevant activities in a fast and efficent manner.

## Graph Output

- To identify malicious/ interesting sub-graph from months of provenance data.

### How

- Node classification (whether the node is malicious or benign).
- Node neighbour classification (whether the node and the neighbours surrounding the node are malicious).
  - If a process is defined as malicious, probably everything it does is malicious.

#### Possible Important features

- Identify all the processes in the graph (Any new process spawned can be malicious example winword.exe executing cmd.exe or powershell.exe). Refer the sample graph to understand the below:
  - node in the graph whose `prov_type` is `process_memory` and had an edge to a node with `prov_type` `path` having name of the executable file. Refer the `/home/vagrant/examples/provenance/tcp-client` in the sample graph.
  - A node with `prov_type` `task` has multiple edges (for example `prov_type` `used` and `prov_label` having either `getattr`, `read`, `perm_read`) to node with `prov_type` `file`. Refer the node with `prov_type` file near `/etc/resolv.conf`.
  - The node with `prov_type` `file` will have an edge to a node with `prov_type` `path` explaining the path of file accessed. Refer `/etc/resolv.conf` in the sample graph.

- Identify all the sockets in the graph (which might be sending or receiving data from a Malicious server (command and control))

- Identify all the file reads/writes in the graph (which might be reading a confidential file).

- Identify the nodes with permission denied? (Do we capture this information. A subject was trying to access a object and got permission denied? and how we can find in graph?)
